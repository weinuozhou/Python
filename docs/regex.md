# 正则表达式

## 什么是正则表达式

在编写处理字符串的程序或网页时,  经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说,  正则表达式就是*记录文本规则的代码*。

很可能你使用过Windows下用于文件查找的通配符,  也就是\*和?。如果你想查找某个目录下的所有的Word文档的话,  你会搜索*.doc。在这里,  *会被解释成任意的字符串。和通配符类似,  正则表达式也是用来进行文本匹配的工具,  只不过比起通配符,  它能更精确地描述你的需求

## 正则表达式入门

* 正则表达式是处理字符串强大的工具,  对于**字符串的检索、替换和匹配验证**较为容易
* 正则表达式测试工具:[https://tool.oschina.net/regex](https://tool.oschina.net/regex)

### 元字符

| 代码 | 说明                         |
|:---:|:---:|
| .    | 匹配除换行符以外的任意字符   |
| \w   | 匹配字母或数字或下划线或汉字 |
| \s   | 匹配任意的空白符             |
| \d   | 匹配数字                     |
| \b   | 匹配单词的开始或结束         |
| ^    | 匹配字符串的开始             |
| $    | 匹配字符串的结束             |

例如: 

* `\ba\w*\b`匹配以字母a开头的单词:先是某个单词开始处(\b),  然后是字母a,然后是任意数量的字母或数字(\w*),  最后是单词结束处(\b)
* `\d+`匹配1个或更多连续的数字。这里的+是和\*类似的元字符,  不同的是*匹配重复任意次(可能是0次),  而+则匹配重复1次或更多次
* `\b\w{6}\b`匹配刚好6个字符的单词

元字符\^和\$都匹配一个位置,  这和\b有点类似。\^**匹配你要用来查找的字符串的开头**,  \$**匹配结尾**。这两个代码在验证输入的内容时非常有用,  比如一个网站如果要求你填写的QQ号必须为5位到12位数字时,  可以使用: `^\d{5,12}$`

### 字符转义

如果你想查找元字符本身的话,  比如你查找`.`,或者`*`,就出现了问题: 你没办法指定它们,  因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此,  你应该使用`\.`和`\*`。当然,  要查找`\`本身,  你也得用`\\`

### 重复

| 代码/语法 | 说明             |
|:---:|:---:|
| *         | 重复零次或更多次 |
| +         | 重复一次或更多次 |
| ?         | 重复零次或一次   |
| {n}       | 重复n次          |
| {n,}      | 重复n次或更多次  |
| {n,m}     | 重复n到m次       |

* `Windows\d+`匹配Windows后面跟1个或更多数字
* `^\w+`匹配一行的第一个单词(或整个字符串的第一个单词,  具体匹配哪个意思得看选项设置)

### 字符类

要想查找数字,  字母或数字,  空白是很简单的,  因为已经有了对应这些字符集合的元字符,  但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？

很简单,  你只需要在**方括号**里列出它们就行了,  像`[aeiou]`就匹配任何一个英文元音字母

### 分枝条件

正则表达式里的分枝条件指的是有几种规则,  如果满足其中任意一种规则都应该当成匹配,  具体方法是用`|`把不同的规则分隔开

使用分枝条件时,  要注意各个条件的顺序,匹配分枝条件时,  将会从左到右地测试每个条件,  **如果满足了某个分枝的话,  就不会去再管其它的条件了**

例如:`0\d{2}-\d{8}|0\d{3}-\d{7}`这个表达式能匹配两种以连字号分隔的电话号码: 一种是三位区号,  8位本地号(如010-12345678),  一种是4位区号,  7位本地号(0376-2233445)

### 分组

我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定**子表达式**(也叫做**分组**),  然后你就可以指定这个子表达式的重复次数

`(\d{1,3}\.){3}\d{1,3}`是一个简单的IP地址匹配表达式
* `\d{1,3}`匹配1到3位的数字
* `(\d{1,3}\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次
* 最后再加上一个一到三位的数字`\d{1,3}`

当然,  这并不是一个正确的ip地址匹配表达式,  它也将匹配300.300.888.999这种不可能存在的IP地址,  只能使用冗长的分组,  选择,  字符类来描述一个正确的IP地址: `((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`

### 贪婪与懒惰

当正则表达式中包含能接受重复的限定符时,  通常的行为是(在使整个表达式能得到匹配的前提下)**匹配尽可能多的字符**。以这个表达式为例: a.*b,  它将会匹配最长的以a开始,  以b结束的字符串。如果用它来搜索aabab的话,  它会匹配整个字符串aabab。这被称为**贪婪匹配**

有时,  我们更需要**懒惰匹配**,  也就是**匹配尽可能少的字符**。前面给出的限定符都可以被转化为懒惰匹配模式,  只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复,  但是在能使整个匹配成功的前提下使用最少的重复

| 代码/语法 | 说明                            |
|:---:|:---:|
| *?        | 重复任意次,  但尽可能少重复      |
| +?        | 重复1次或更多次,  但尽可能少重复 |
| ??        | 重复0次或1次,  但尽可能少重复    |
| {n,m}?    | 重复n到m次,  但尽可能少重复      |
| {n,}?     | 重复n次以上,  但尽可能少重复     |

## Python实现正则表达式

* **正则表达式常用的匹配规则**
  
|模式|描述|
|:---:|:---|
|\w|匹配字母、数字及下划线|
|\W|匹配不是字母、数字及下划线的字符|
|\s|匹配任意空白字符|
|\S|匹配任意非空白字符,等价于[\t\n\r\f]|
|\d|匹配任意数字,等价于[0-9]|
|\D|匹配任意非数字的字符|
|\A|匹配字符串的开头|
|\Z|匹配字符串的结尾|
|\n|匹配一个换行符|
|\t|匹配一个制表符|
|^|匹配一行字符串的开头|
|$|匹配一行字符串的结尾|
|.|匹配任意字符(不包括换行符)|
|\*|匹配0次或多次|
|\+|匹配一次或多次|
|?|匹配0次或1次(非贪婪模式)|
|[...]|匹配一组字符|
|{n}|匹配n次|
|{n,m}|匹配n-m次(贪婪模式)|
|a\|b|匹配a或者b|
|()|匹配括号内的表达式,  表示一个组|

* **正则表达式修饰符**

|修饰符|含义|
|:---:|:---:|
|re.I|匹配对大小写不敏感|
|re.L|做本地化识别匹配|
|re.M|多行匹配,影响^和$|
|re.S|使.可以匹配包括换行在内的所有字符|
|re.U|根据Unicode字符集解析字符|

在Python中,  你可以使用 re 模块来处理正则表达式。以下是一些基本的正则表达式操作

### `match`方法

```python
match(pattern, string, flags=0)
```

`match`方法会从**字符串开始的位置**匹配正则表达式,  匹配到则返回`match`对象否则返回None

* `group`:按组输出匹配到的内容
* `span`:可以输出匹配的范围,在原字符串中的位置

```python
content = "hello 123 45678 This is a  Regex demo"
result = re.match('^hello.*demo$',content)
print(f'匹配到的正则表达式对象的数据类型为"{type(result)}')
print(f'匹配到的正则表达式对象为"{result}')
print(f'输出匹配到的内容为:{result.group()}')
print(f'匹配到的字符串在原字符串的位置为:{result.span()}')
```

### `search`方法

```python
search(pattern, string, flags=0)
```

* `match`方法是通过**字符串的开头**开始匹配的,  一旦开头不匹配,  整个匹配就失败了
* `search`方法会**扫描整个字符串**匹配正则表达式,  匹配到则返回**第一个相应的匹配对象**,否则返回None
* `group`:按组输出匹配到的内容
* `span`:可以输出匹配的范围,在原字符串中的位置

```python
content = "hello 123 45678 This is a  Regex 123 45678 hello world"
result = re.search('\d+\s\d+',content)
print(f'匹配到的正则表达式对象的数据类型为"{type(result)}')
print(f'匹配到的正则表达式对象为"{result}')
print(f'输出匹配到的内容为:{result.group()}')
print(f'匹配到的字符串在原字符串的位置为:{result.span()}')
```

### `findall`方法

```python
import re
re.findall(pattern, string, flags=0)
```

* `findall`方法返回匹配到正则表达式的字符串的所有内容

```python
content = "hello 123 45678 This is a  Regex 123 45678 hello world"
result = re.findall('\d+\s\d+',content)
print(f'匹配到的正则表达式对象的数据类型为"{type(result)}')
print(f'匹配到的正则表达式对象为"{result}')
```

### `compile`方法

```python
pattern = r'(.*?):(.*)' # 正则表达式样式
prog = re.compile(pattern) # prog是一个正则表达式对象,  可以使用search、match、findall等方法进行匹配
```

该方法可以将正则表达式的样式编译成一个**正则表达式对象**,  便于使用`match`、`search`和`findall`进行匹配

```python
content = 'name:grey age:22'
pattern = r'(.*):(\d+)' 
prog = re.compile(pattern)
result = re.findall(prog,content)
print(f'匹配到的正则表达式对象的数据类型为"{type(result)}')
print(f'匹配到的正则表达式对象为"{result}')
```
